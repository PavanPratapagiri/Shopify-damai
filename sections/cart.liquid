<!-- /sections/cart.liquid -->
{%- liquid
  assign hide_quantity = 'quantity--hide'
  if settings.cart_show_quantity
    assign hide_quantity = ''
  endif

  assign ajax_disable = false
  assign no_ajax_class = ''
  if settings.cart_style == 'compatible'
    assign ajax_disable = true
    assign no_ajax_class = 'no--ajax'
  endif

  assign full_init = ''
  assign empty_init = 'cart--hidden'
  if cart.item_count == 0
    assign empty_init = ''
    assign full_init = 'cart--hidden'
  endif
-%}

<style>
  /* Loading state styles */
  .cart--loading {
    position: relative;
    pointer-events: none;
    opacity: 0.6;
  }
  
  .cart--loading::after {
    content: '';
    position: absolute;
    top: 50%;
    left: 50%;
    width: 40px;
    height: 40px;
    margin: -20px 0 0 -20px;
    border: 3px solid #f3f3f3;
    border-top: 3px solid #333;
    border-radius: 50%;
    animation: cart-spin 1s linear infinite;
    z-index: 9999;
  }
  
  @keyframes cart-spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
  }
  
  /* Error message styles */
  .cart__error {
    background: #fee;
    color: #c33;
    padding: 12px 16px;
    border-radius: 4px;
    margin-bottom: 16px;
    display: none;
  }
  
  .cart__error.active {
    display: block;
    animation: slideIn 0.3s ease;
  }
  
  @keyframes slideIn {
    from {
      opacity: 0;
      transform: translateY(-10px);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }
  
  /* Smooth transitions */
  .cart__items__row {
    transition: opacity 0.3s ease, transform 0.3s ease;
  }
  
  .cart__items__row.removing {
    opacity: 0;
    transform: translateX(-20px);
  }
  
  /* Prevent layout shift */
  .cart__template {
    min-height: 400px;
  }
  
  /* Smooth quantity input transitions */
  .quantity__input {
    transition: background-color 0.2s ease, border-color 0.2s ease;
  }
  
  .quantity__input.updating {
    background-color: #f9f9f9;
    border-color: #ccc;
  }
  
  .quantity__button {
    transition: opacity 0.15s ease, transform 0.1s ease;
    user-select: none;
  }
  
  .quantity__button:active {
    transform: scale(0.95);
  }
  
  .quantity__button:disabled {
    opacity: 0.4;
    cursor: not-allowed;
  }
</style>

<div class="cart__template {{ no_ajax_class }} {{ hide_quantity }} {{ section.settings.bg }}"
  data-cart-message-container
  data-section-id="{{ section.id }}"
  data-section-type="cart"
  data-ajax-disable="{{ ajax_disable }}"
  style="--PT: {{ section.settings.padding_top }}px; --PB: {{ section.settings.padding_bottom }}px;">
  
  <!-- Error message container -->
  <div class="cart__error" data-cart-error></div>
  
  {% comment %} Cart is empty {% endcomment %}
  <div class="cart__empty__page {{ empty_init }}" data-cart-empty>
    {% render 'cart-empty' %}
  </div>
  
  {% comment %} Cart is full {% endcomment %}
  <div class="{{ section.settings.width }} section-padding {{ full_init }}" data-cart-form data-cart-loading>
    <form action="{{ routes.cart_url }}" method="post" novalidate class="cart">
      <h3 class="cart__page__title body-size-8">{{ 'cart.general.title' | t }}</h3>
      <div class="errors" data-form-errors style="display: none;"></div>
      <div class="cart__items__grid cart__heading__wrapper">
        <div class="cart__heading__back">
          <a href="{{ settings.cart_continue_browsing | default: routes.all_products_collection_url }}" class="cart__heading cart__return">
            {% render 'icon-arrow-long-left' %}
            &nbsp;
            {{ 'cart.general.continue_browsing' | t }}
          </a>
        </div>
        <div class="cart__items__price">
          <p class="cart__heading">{{ 'cart.label.price' | t }}</p>
        </div>
        <div class="cart__items__quantity">
          <p class="cart__heading">{{ 'cart.label.quantity' | t }}</p>
        </div>
        <div class="cart__items__total">
          <p class="cart__heading">{{ 'cart.label.total' | t }}</p>
        </div>
      </div>
      <div class="template__cart__body">
        <div class="errors" data-form-errors style="display: none;"></div>
        <div data-cart-form>
            {% comment %}
              The following snippet is refreshed via ajax with
              cart.items.liquid when the quantity is adjusted.
            {% endcomment %}
            <div data-line-items>
            {% render 'cart-line-items',  wpddrawer: false %}
            </div>
        </div>

        <div class="template__cart__footer{% if additional_checkout_buttons and settings.cart_show_additional_buttons %} template__cart__footer--additional_buttons{% endif %}" data-cart-bottom>

          <div class="cart__footer__notes">
            {%- if settings.cart_notes_enable -%}
              <label class="cart__notes__label" for="CartSpecialInstructions">{{ 'cart.general.note' | t }}</label>
              <textarea name="note" class="input-full" id="CartSpecialInstructions" data-cart-note>{{ cart.note }}</textarea>
            {%- endif -%}
          </div>
          <div class="cart__footer__shipping">
            {%- if settings.cart_shipping_enable -%}
              {% render 'cart-shipping' %}
            {%- endif -%}
          </div>
          <div class="cart__footer__total">
            {% if settings.cart_custom_message_enable and settings.cart_custom_message_text != blank %}
              <div class="cart__message cart__message--custom">
                {{ settings.cart_custom_message_text }}
              </div>
            {% endif %}

            <div class="cart__page__shipping">
              {% assign free_shipping_text = block.settings.message | default: settings.message %}
{% assign is_enable = false %}
{% assign show_wheel = true %}

{% assign font_size_class = font_size_class | default: '' %}

{% if block.settings.show_wheel == false %}
  {% assign show_wheel = false %}
{% endif %}

{% if block.settings.message != blank %}
  {% assign is_enable = true %}
{% endif %}

{% if settings.show_free_shipping_message and settings.free_shipping_limit != blank and free_shipping_text != blank %}
  {% assign is_enable = true %}
{% endif %}

{% if is_enable %}
  {% assign limit = settings.free_shipping_limit | plus: 0 %}
  {% assign limit_currency = limit | times: 100 %}
  {% assign subtotal_without_currency = cart.total_price | plus: 0 | divided_by: 100 %}

  {% capture left_to_spend %}
    <span data-left-to-spend class="strong">
      {% if settings.currency_code_enable %}
        {{ limit_currency | minus: cart.total_price | money_with_currency }}
      {% else %}
        {{ limit_currency | minus: cart.total_price | money_without_trailing_zeros }}
      {% endif %}
    </span>
  {% endcapture %}

  {% assign free_shipping_message = free_shipping_text | replace: '||amount||', left_to_spend %}
  {% assign qualified_shipping_message = 'cart.general.qualified_shipping_message' | t %}
  {% assign class_message = '' %}

  {% if subtotal_without_currency >= limit %}
    {% if qualified_shipping_message != blank %}
      {% assign class_message = 'is-success' %}
    {% else %}
      {% assign class_message = 'is-hidden' %}
    {% endif %}
  {% elsif subtotal_without_currency == 0 %}
    {% comment %} {% assign class_message = 'is-hidden' %} {% endcomment %}
  {% endif %}

  <p class="cart__message {{ class_message }} {{ font_size_class }}" data-cart-message="{% if qualified_shipping_message != blank %}true{% else %}false{% endif %}" data-limit="{{ limit }}">
    {% if show_wheel %}
      {% assign percent = limit | minus: subtotal_without_currency | times: 100 | divided_by: limit %}
      {% assign percent = 100 | minus: percent %}

      {% if percent > 100 %}
        {% assign percent = 100 %}
      {% endif %}

      <small class="cart__graph">
        {% for i in (1..6) %}
          <small class="cart__graph-dot cart__graph-dot--{{ i }}"></small>
        {% endfor %}
        {%- assign stroke_dashoffset = '87.96459430051421' -%}
        {%- if settings.cart_style == 'compatible' -%}
          {%- assign math_pi = 3.14159265359 -%}
          {%- assign stroke_circumference = 28 | times: math_pi -%}
          {%- assign stroke_calculate = percent | times: stroke_circumference -%}
          {%- assign stroke_calculate = stroke_calculate | divided_by: 100 | divided_by: 2 -%}
          {%- assign stroke_dashoffset = stroke_circumference | minus: stroke_calculate -%}
        {%- endif -%}

        <svg height="18" width="18">
          <circle r="7" cx="9" cy="9" />
          <circle class="cart__graph-progress" stroke-dasharray="87.96459430051421 87.96459430051421" style="stroke-dashoffset: {{ stroke_dashoffset }}" data-cart-progress data-percent="{{ percent }}" r="7" cx="9" cy="9" />
        </svg>
      </small>
    {% endif %}

    {% if qualified_shipping_message != blank %}
      <span class="cart__message-success">{{ qualified_shipping_message }}</span>
    {% endif %}

    <span class="cart__message-default">
      {{ free_shipping_message }}
    </span>
  </p>
{% endif %}

            </div>

            <div class="page__footer__subtotal" data-cart-subtotal>
              {% render 'cart-subtotal' %}
            </div>

            <p>
              <span class="cart__footer__label">{{ 'cart.general.subtotal' | t }}</span>
              <span class="cart__footer__value wcp-original-cart-total" data-cart-final>
                {{ cart.total_price | money_with_currency }}
              </span>
            
            </p>
              <span class="cart__footer__value wcp-cart-total"></span>
                       <div class="additional-notes">
                          <span class="wcp-minimums-note"></span>
                          <span class="wcp-extra-note "></span>
                      </div>
                      {% render "wcp_multi_currency_msg" %}  
            
            <p class="cart__footer__small">{{ 'cart.general.shipping_at_checkout' | t }}</p>
          </div>

          <div class="cart__footer__checkout">

{% assign wcp_wholesale_customer = false %}
{% if shop.metafields.wcp_status.wcp_status != 'disabled' and customer %}
{% assign active_discounts = shop.metafields.wcp_active_discounts.wcp_active_discounts %}
{% assign active_discounts_array = active_discounts | split: ',' %}
{% assign customer_tags = blank %}
{% for tag in customer.tags %}
{% assign tempTag = tag | downcase %}
{% assign customer_tags = customer_tags | prepend:tempTag %}
{% unless forloop.last %}
{% assign customer_tags = customer_tags | prepend:','  %}
{% endunless %}
{% endfor %}
{% assign customer_tags = customer_tags | split:',' %}
{% assign active_discounts = active_discounts | downcase %}
{% for discount_key in active_discounts_array %}
{% assign key_split = discount_key | split: '-' %}
{% assign key_split_length = key_split | size %}
{% if key_split_length > 2 %}
{% assign removeable_key = key_split.last | prepend: '-' %}
{% assign wcp_customer_tag = discount_key | remove_last: removeable_key %}
{% else %}
{% assign wcp_customer_tag = key_split[0] %}
{% endif %}
{% assign wcp_customer_tag = wcp_customer_tag | downcase %}
{% if customer_tags contains wcp_customer_tag %}
{% assign wcp_wholesale_customer = true %}
{% endif %}
{% endfor %}
{% endif %}
{% if wcp_wholesale_customer == true %}
            <button type="submit" class="wcp_checkout_btn btn btn--primary btn--large checkout__button WPDcheckoutBTN" style="color:white; padding: 12px 20px; margin-bottom: 2px;" disabled>{{ 'cart.general.checkout' | t }}</button>
            <script>
              document.addEventListener("DOMContentLoaded", function(){
               var hidecheckoutBTN = setInterval(function(){
                if(window.wcp_data){
                	    document.getElementsByClassName("WPDcheckoutBTN")[0].removeAttribute("disabled");
                        clearInterval(hidecheckoutBTN);
            	}
                },100) // Reduced from 2500ms to 100ms check interval
                
              });  
            </script>   
  {% else %}            
            <button type="submit" name="checkout" class="btn btn--primary btn--large checkout__button">
              {{ 'cart.general.checkout' | t }}
            </button>
            {% endif %}
         </div>

          <div class="cart__footer__update">
            <span class="cart__update" data-update-button>
              <span class="cart__update__icon">{% render 'icon-sync' %}</span>
              <button type="submit" name="update" class="text-link">
                {{ 'cart.general.update' | t }}
              </button>
            </span>
          </div>

          {% if additional_checkout_buttons and settings.cart_show_additional_buttons %}
            <div class="cart__footer__additional">
              <div class="additional-checkout-buttons">
                {{ content_for_additional_checkout_buttons }}
              </div>
            </div>
          {% endif %}
        </div>
      </div>
             <div>
                  {% if customer.tags contains "wpdnet" %}
                      {% if shop.metafields.wcp_net.isNetEnabled == "true" or shop.metafields.wcp_net.isNetEnabled == "1" %}
                          <div style="margin-top:30px;float:right;width: 23%;">
                              <p>{{shop.metafields.wcp_net.netCartMsg}}</p>
                              <a id="wcp-30-open" class="btn btn--primary btn--large" style="width:100%;cursor:pointer;">{{shop.metafields.wcp_net.netBtnMsg}}</a>
                          </div>
                      {% endif %}
                  {% endif %}
              </div>
    </form>
  </div>
</div>

<script>
(function() {
  'use strict';
  
  // Volume Discount Tiers Configuration - matches product multi-variants
  const DISCOUNT_TIERS = [
    { min: 1, max: 4, discount: 0.39, price: 212.22 },
    { min: 5, max: 9, discount: 0.43, price: 198.30 },
    { min: 10, max: Infinity, discount: 0.45, price: 191.34 }
  ];
  
  // Configuration
  const CONFIG = {
    isWholesaleCustomer: {% if wcp_wholesale_customer == true %}true{% else %}false{% endif %},
    wcpDelay: 500,
    debounceDelay: 300,
    maxRetries: 3,
    discountTiers: DISCOUNT_TIERS
  };
  
  // State management
  const state = {
    isUpdating: false,
    updateQueue: [],
    retryCount: 0
  };
  
  // Pricing utilities
  const PricingUtils = {
    getTotalQuantity(cart) {
      return cart.items.reduce((sum, item) => sum + item.quantity, 0);
    },
    
    getDiscountTier(totalQuantity) {
      if (totalQuantity === 0) return null;
      return DISCOUNT_TIERS.find(t => totalQuantity >= t.min && totalQuantity <= t.max);
    },
    
    getDiscountedPrice(totalQuantity, msrpPrice) {
      if (totalQuantity === 0) return msrpPrice;
      const tier = this.getDiscountTier(totalQuantity);
      return tier ? Math.round(msrpPrice * (1 - tier.discount)) : msrpPrice;
    },
    
    getNextTierInfo(totalQuantity) {
      if (totalQuantity === 0) return null;
      const nextTier = DISCOUNT_TIERS.find(t => totalQuantity < t.min);
      if (nextTier) {
        const currentTier = this.getDiscountTier(totalQuantity);
        const itemsNeeded = nextTier.min - totalQuantity;
        const additionalDiscount = Math.round((nextTier.discount - (currentTier?.discount || 0)) * 100);
        return {
          itemsNeeded,
          additionalDiscount,
          nextTierDiscount: Math.round(nextTier.discount * 100),
          nextTierPrice: nextTier.price
        };
      }
      return null;
    },
    
    calculateLineTotal(quantity, unitPrice) {
      return quantity * unitPrice;
    }
  };
  
  // Cart Manager Class
  class CartManager {
    constructor() {
      this.errorContainer = document.querySelector('[data-cart-error]');
      this.cartLoading = document.querySelector('[data-cart-loading]');
      this.cartEmpty = document.querySelector('[data-cart-empty]');
      this.cartForm = document.querySelector('[data-cart-form]');
      this.debounceTimers = new Map(); // Track debounce timers per item
      this.pendingUpdates = new Map(); // Track pending quantity updates
    }
    
    // Initialize cart
    init() {
      this.attachEventListeners();
      this.preventDefaultUpdate();
      // Calculate and display prices on initial load
      this.initializePrices();
    }
    
    // Initialize prices on page load
    async initializePrices() {
      try {
        // Fetch current cart data
        const response = await fetch('/cart.js', {
          headers: {
            'X-Requested-With': 'XMLHttpRequest'
          }
        });
        
        if (response.ok) {
          const cart = await response.json();
          // Apply volume discount pricing to all items
          this.updateItemPrices(cart);
        }
      } catch (error) {
        console.error('Error initializing prices:', error);
      }
    }
    
    // Attach all event listeners
    attachEventListeners() {
      // Use event delegation for better performance
      document.addEventListener('click', this.handleClick.bind(this));
      document.addEventListener('change', this.handleChange.bind(this));
      document.addEventListener('input', this.handleInput.bind(this));
    }
    
    // Handle all click events
    handleClick(e) {
      const plusBtn = e.target.closest('.quantity__button--plus');
      const minusBtn = e.target.closest('.quantity__button--minus');
      const removeBtn = e.target.closest('[data-remove-key]');
      const checkoutBtn = e.target.closest('.checkout__button');
      
      // Don't interfere with checkout button
      if (checkoutBtn) {
        return;
      }
      
      if (plusBtn) {
        e.preventDefault();
        e.stopImmediatePropagation(); // Stop other listeners from firing
        this.adjustQuantity(plusBtn, 1);
      } else if (minusBtn) {
        e.preventDefault();
        e.stopImmediatePropagation(); // Stop other listeners from firing
        this.adjustQuantity(minusBtn, -1);
      } else if (removeBtn) {
        e.preventDefault();
        const key = removeBtn.getAttribute('data-remove-key');
        this.removeItem(key);
      }
    }
    
    // Handle change events with debounce
    handleChange(e) {
      const qtyInput = e.target.closest('.quantity__input');
      if (qtyInput) {
        const key = qtyInput.getAttribute('data-update-cart');
        const newQty = parseInt(qtyInput.value) || 0;
        
        qtyInput.classList.add('updating');
        
        // Clear existing debounce timer for this item
        if (this.debounceTimers.has(key)) {
          clearTimeout(this.debounceTimers.get(key));
        }
        
        // Store the pending update
        this.pendingUpdates.set(key, newQty);
        
        // Debounce the cart update
        const timer = setTimeout(() => {
          this.updateCartDebounced(key, newQty);
          this.debounceTimers.delete(key);
          qtyInput.classList.remove('updating');
        }, CONFIG.debounceDelay);
        
        this.debounceTimers.set(key, timer);
      }
    }
    
    // Handle input events with debounce
    handleInput(e) {
      const qtyInput = e.target.closest('.quantity__input');
      if (qtyInput) {
        // Validate input immediately
        let value = parseInt(qtyInput.value) || 0;
        if (value < 0) value = 0;
        qtyInput.value = value;
      }
    }
    
    // Adjust quantity by delta with optimistic UI update
    adjustQuantity(button, delta) {
      const wrapper = button.closest('[data-quantity-selector]');
      const input = wrapper.querySelector('.quantity__input');
      const key = input.getAttribute('data-update-cart');
      const currentQty = parseInt(input.value) || 0;
      const newQty = Math.max(0, currentQty + delta);
      
      // Instantly update the UI (optimistic update)
      input.value = newQty;
      input.classList.add('updating');
      
      // Disable buttons temporarily to prevent rapid clicking
      const plusBtn = wrapper.querySelector('.quantity__button--plus');
      const minusBtn = wrapper.querySelector('.quantity__button--minus');
      plusBtn.disabled = true;
      minusBtn.disabled = true;
      
      // Store the pending update
      this.pendingUpdates.set(key, newQty);
      
      // Clear existing debounce timer for this item
      if (this.debounceTimers.has(key)) {
        clearTimeout(this.debounceTimers.get(key));
      }
      
      // Debounce the actual cart update
      const timer = setTimeout(() => {
        this.updateCartDebounced(key, newQty);
        this.debounceTimers.delete(key);
        
        // Re-enable buttons
        plusBtn.disabled = false;
        minusBtn.disabled = false;
        input.classList.remove('updating');
      }, CONFIG.debounceDelay);
      
      this.debounceTimers.set(key, timer);
    }
    
    // Debounced cart update
    async updateCartDebounced(key, quantity) {
      this.pendingUpdates.delete(key);
      await this.updateCart(key, quantity);
    }
    
    // Remove item with animation
    removeItem(key) {
      const row = document.querySelector(`[data-cart-item] input[data-update-cart="${key}"]`)?.closest('[data-cart-item]');
      if (row) {
        row.classList.add('removing');
        setTimeout(() => this.updateCart(key, 0), 300);
      } else {
        this.updateCart(key, 0);
      }
    }
    
    // Update cart via AJAX
    async updateCart(key, quantity) {
      if (state.isUpdating) {
        // Queue the update
        state.updateQueue.push({ key, quantity });
        return;
      }
      
      state.isUpdating = true;
      this.showLoading();
      this.hideError();
      
      try {
        const response = await fetch('/cart/change.js', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'X-Requested-With': 'XMLHttpRequest'
          },
          body: JSON.stringify({ id: key, quantity: quantity })
        });
        
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        const cart = await response.json();
        
        // Wait for WCP if needed
        if (CONFIG.isWholesaleCustomer) {
          await this.waitForWCP();
        }
        
        await this.refreshCart(cart);
        state.retryCount = 0;
        
        // Dispatch success event for product multi-variants page
        this.dispatchCartEvent('success', cart);
        
        // Notify product page of cart update
        document.dispatchEvent(new Event('cartUpdateComplete'));
        
      } catch (error) {
        console.error('Cart update error:', error);
        this.showError('Unable to update cart. Please try again.');
        
        // Retry logic
        if (state.retryCount < CONFIG.maxRetries) {
          state.retryCount++;
          setTimeout(() => this.updateCart(key, quantity), 1000 * state.retryCount);
        }
        
      } finally {
        state.isUpdating = false;
        this.hideLoading();
        
        // Process queued updates
        if (state.updateQueue.length > 0) {
          const next = state.updateQueue.shift();
          setTimeout(() => this.updateCart(next.key, next.quantity), 100);
        }
      }
    }
    
    // Wait for WCP to load
    waitForWCP() {
      return new Promise((resolve) => {
        if (window.wcp_data) {
          setTimeout(resolve, CONFIG.wcpDelay);
        } else {
          const checkInterval = setInterval(() => {
            if (window.wcp_data) {
              clearInterval(checkInterval);
              setTimeout(resolve, CONFIG.wcpDelay);
            }
          }, 100);
          
          // Timeout after 5 seconds
          setTimeout(() => {
            clearInterval(checkInterval);
            resolve();
          }, 5000);
        }
      });
    }
    
    // Refresh cart display efficiently
    async refreshCart(cart) {
      try {
        // Fetch only the cart section HTML
        const response = await fetch(window.location.href + '?section_id=cart', {
          headers: {
            'X-Requested-With': 'XMLHttpRequest'
          }
        });
        
        const html = await response.text();
        const parser = new DOMParser();
        const doc = parser.parseFromString(html, 'text/html');
        
        // Update specific sections
        this.updateSection('[data-line-items]', doc);
        this.updateSection('[data-cart-subtotal]', doc);
        this.updateSection('[data-cart-final]', doc);
        this.updateSection('[data-cart-message]', doc);
        
        // Update WCP elements if they exist
        this.updateSection('.wcp-cart-total', doc);
        this.updateSection('.wcp-minimums-note', doc);
        this.updateSection('.wcp-extra-note', doc);
        
        // Update individual item prices from cart data with volume pricing
        this.updateItemPrices(cart);
        
        // Handle empty cart
        this.toggleEmptyCart(cart.item_count === 0);
        
        // Update header cart
        this.updateHeaderCart(cart);
        
        // Re-trigger WCP if needed
        if (CONFIG.isWholesaleCustomer && window.wcpRefreshCartTotal) {
          window.wcpRefreshCartTotal();
        }
        
      } catch (error) {
        console.error('Cart refresh error:', error);
        // Fallback to full page reload
        window.location.reload();
      }
    }
    
    // Update individual item prices to match cart data with volume discount pricing
    updateItemPrices(cart) {
      const formatter = new Intl.NumberFormat('en-US', {
        style: 'currency',
        currency: cart.currency || 'USD'
      });
      
      const totalQty = PricingUtils.getTotalQuantity(cart);
      let calculatedTotal = 0;
      
      cart.items.forEach(item => {
        // Get MSRP (compare_at_price or original price)
        const msrpPrice = item.variant.compare_at_price || item.original_price;
        
        // Calculate volume-discounted unit price based on total cart quantity
        const volumeDiscountedPrice = PricingUtils.getDiscountedPrice(totalQty, msrpPrice);
        
        // Use the lower of: volume discount price or Shopify's final_price (from other discounts)
        const finalUnitPrice = Math.min(volumeDiscountedPrice, item.final_price);
        
        // Calculate line total: quantity × unit price
        const lineTotal = PricingUtils.calculateLineTotal(item.quantity, finalUnitPrice);
        
        // Add to running total
        calculatedTotal += lineTotal;
        
        // Update unit price display
        const priceElement = document.querySelector(`[data-item-price="${item.key}"]`);
        if (priceElement) {
          priceElement.textContent = formatter.format(finalUnitPrice / 100);
        }
        
        // Update compare-at price if exists
        const comparePriceElement = document.querySelector(`[data-compare-price="${item.key}"]`);
        if (comparePriceElement && msrpPrice > finalUnitPrice) {
          comparePriceElement.textContent = formatter.format(msrpPrice / 100);
          comparePriceElement.style.display = '';
        } else if (comparePriceElement) {
          comparePriceElement.style.display = 'none';
        }
        
        // Update original price if discounted
        const originalPriceElement = document.querySelector(`[data-original-price="${item.key}"]`);
        if (originalPriceElement && item.original_price > finalUnitPrice) {
          originalPriceElement.textContent = formatter.format(item.original_price / 100);
          originalPriceElement.style.display = '';
        } else if (originalPriceElement) {
          originalPriceElement.style.display = 'none';
        }
        
        // Update line total (quantity × unit price)
        const lineTotalElement = document.querySelector(`[data-line-total="${item.key}"]`);
        if (lineTotalElement) {
          lineTotalElement.textContent = formatter.format(lineTotal / 100);
        }
        
        // Update WPD wholesale pricing line price
        const wpdLineElement = document.querySelector(`[data-wpd-cart-item="${item.key}"][data-wpd-cart-line-price]`);
        if (wpdLineElement) {
          wpdLineElement.textContent = formatter.format(lineTotal / 100);
        }
        
        // Update quantity input to match cart
        const qtyInput = document.querySelector(`input[data-update-cart="${item.key}"]`);
        if (qtyInput && parseInt(qtyInput.value) !== item.quantity) {
          qtyInput.value = item.quantity;
        }
        
        // Update data attributes for wholesale pricing compatibility
        if (wpdLineElement) {
          wpdLineElement.setAttribute('data-wpd-cart-drawer-quantity', item.quantity);
          wpdLineElement.setAttribute('data-wpd-cart-drawer-variant-price', finalUnitPrice);
        }
        
        // Update all price data attributes
        const allPriceElements = document.querySelectorAll(`[data-wpd-cart-drawer-variant-price][data-wpd-cart-drawer-item="${item.key}"]`);
        allPriceElements.forEach(el => {
          el.setAttribute('data-wpd-cart-drawer-variant-price', finalUnitPrice);
        });
      });
      
      // Update cart subtotal (sum of all line totals)
      const subtotalElement = document.querySelector('[data-cart-final]');
      if (subtotalElement) {
        subtotalElement.textContent = formatter.format(calculatedTotal / 100);
      }
      
      // Update original cart total display
      const originalTotal = document.querySelector('.wcp-original-cart-total');
      if (originalTotal) {
        originalTotal.textContent = formatter.format(calculatedTotal / 100);
      }
      
      // Log pricing details for debugging
      console.log('Cart Pricing Summary:', {
        totalQuantity: totalQty,
        itemCount: cart.items.length,
        calculatedTotal: formatter.format(calculatedTotal / 100),
        items: cart.items.map(item => {
          const msrpPrice = item.variant.compare_at_price || item.original_price;
          const volumeDiscountedPrice = PricingUtils.getDiscountedPrice(totalQty, msrpPrice);
          const finalUnitPrice = Math.min(volumeDiscountedPrice, item.final_price);
          const lineTotal = PricingUtils.calculateLineTotal(item.quantity, finalUnitPrice);
          return {
            title: item.product_title,
            quantity: item.quantity,
            msrp: formatter.format(msrpPrice / 100),
            volumePrice: formatter.format(volumeDiscountedPrice / 100),
            finalPrice: formatter.format(finalUnitPrice / 100),
            lineTotal: formatter.format(lineTotal / 100)
          };
        })
      });
    }
    
    // Update a specific section
    updateSection(selector, doc) {
      const newElement = doc.querySelector(selector);
      const currentElement = document.querySelector(selector);
      
      if (newElement && currentElement) {
        currentElement.innerHTML = newElement.innerHTML;
      }
    }
    
    // Toggle empty cart state
    toggleEmptyCart(isEmpty) {
      if (isEmpty) {
        this.cartEmpty?.classList.remove('cart--hidden');
        this.cartForm?.closest('[data-cart-loading]')?.classList.add('cart--hidden');
      } else {
        this.cartEmpty?.classList.add('cart--hidden');
        this.cartForm?.closest('[data-cart-loading]')?.classList.remove('cart--hidden');
      }
    }
    
    // Update header cart count
    updateHeaderCart(cart) {
      // Update cart count
      document.querySelectorAll('[data-header-cart-count], [data-cart-count-badge]').forEach(el => {
        el.textContent = cart.item_count;
        if (cart.item_count === 0) {
          el.classList.add('hidden');
        } else {
          el.classList.remove('hidden');
        }
      });
      
      // Update cart price
      const formatter = new Intl.NumberFormat('en-US', {
        style: 'currency',
        currency: cart.currency || 'USD'
      });
      
      document.querySelectorAll('[data-header-cart-price]').forEach(el => {
        el.textContent = formatter.format(cart.total_price / 100);
      });
    }
    
    // Show loading state
    showLoading() {
      this.cartLoading?.classList.add('cart--loading');
    }
    
    // Hide loading state
    hideLoading() {
      this.cartLoading?.classList.remove('cart--loading');
    }
    
    // Show error message
    showError(message) {
      if (this.errorContainer) {
        this.errorContainer.textContent = message;
        this.errorContainer.classList.add('active');
        
        // Auto-hide after 5 seconds
        setTimeout(() => this.hideError(), 5000);
      }
    }
    
    // Hide error message
    hideError() {
      this.errorContainer?.classList.remove('active');
    }
    
    // Prevent default form submission for update button
    preventDefaultUpdate() {
      const updateButton = document.querySelector('[name="update"]');
      if (updateButton) {
        updateButton.addEventListener('click', (e) => {
          e.preventDefault();
          return false;
        });
      }
      
      // Ensure checkout button submits the form
      const checkoutButtons = document.querySelectorAll('.checkout__button');
      checkoutButtons.forEach(button => {
        button.addEventListener('click', (e) => {
          // Don't prevent default - let it submit the form
          if (!button.disabled) {
            // Allow normal form submission
            return true;
          }
        });
      });
    }
    
    // Dispatch custom cart event
    dispatchCartEvent(type, cart) {
      document.dispatchEvent(new CustomEvent('theme:cart:change', {
        detail: { type, cart },
        bubbles: true
      }));
    }
  }
  
  // Initialize on DOM ready
  let cartManager;
  
  function initCartPage() {
    if (!cartManager) {
      cartManager = new CartManager();
    }
    cartManager.init();
  }
  
  // Make globally accessible
  window.initCartPage = initCartPage;
  
  // Auto-initialize
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initCartPage);
  } else {
    initCartPage();
  }
  
  // Re-initialize on visibility change
  document.addEventListener('theme:cart:open', () => {
    setTimeout(initCartPage, 100);
  });
  
})();
</script>
            
{% schema %}
{
  "name": "Cart",
  "settings": [
    {
      "type": "select",
      "id": "bg",
      "label": "Background color",
      "default": "palette--light bg--neutral",
      "options": [
        { "value": "palette--light bg--neutral", "label": "Default"},
        { "value": "palette--light bg--accent", "label": "Light"},
        { "value": "palette--dark bg--invert", "label": "Dark"},
        { "value": "palette--dark bg--invert--accent", "label": "Dark accent"},
        { "value": "palette--bright bg--bright", "label": "Bright"},
        { "value": "palette--bright bg--bright--accent", "label": "Bright accent"}
      ]
    },
    {
      "type": "header",
      "content": "Section spacing"
    },
    {
      "type": "select",
      "id": "width",
      "label": "Width",
      "default": "wrapper",
      "options": [
        { "value": "wrapper--full", "label": "Full width padded" },
        { "value": "wrapper", "label": "Page width" },
        { "value": "wrapper--narrow", "label": "Page width narrow" }
      ]
    },
    {
      "type": "range",
      "id": "padding_top",
      "min": 0,
      "max": 180,
      "step": 2,
      "unit": "px",
      "label": "Padding top",
      "default": 36
    },
    {
      "type": "range",
      "id": "padding_bottom",
      "min": 0,
      "max": 180,
      "step": 2,
      "unit": "px",
      "label": "Padding bottom",
      "default": 36
    }
  ]
}
{% endschema %}
